
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions to make rules more readable.
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      // Check for a custom 'role' field on the user's document in Firestore.
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // This function checks if the user making the request is a member of the group
    // specified in the document being accessed.
    function isGroupMember(docData) {
      return isSignedIn() && request.auth.uid in docData.groupMemberIds;
    }
    
    // --- Collection Rules ---

    // Site settings: everyone can read, only admins can write.
    match /settings/general {
      allow get: if true;
      allow write: if isAdmin();
    }

    match /users/{userId} {
      // Any signed-in user can view any user's profile (needed for member lists, search, etc.)
      allow get: if isSignedIn();
      // Allow signed-in users to list/query the users collection (for searching members).
      allow list: if isSignedIn();
      // A user can only create their own document.
      allow create: if isOwner(userId);
      // A user can update their own document, or an admin can update any.
      allow update: if isOwner(userId) || isAdmin();
      // Only admins can delete users.
      allow delete: if isAdmin();
    }

    match /groups/{groupId} {
      // Allow reading (get/list) a group document if the user's ID is in the memberIds list.
      // This rule works for both single document fetches and queries.
      allow read: if isSignedIn() && request.auth.uid in resource.data.memberIds;
      
      // To create a group, the user must be signed in, be the creator, and be in the initial members list.
      allow create: if isSignedIn() 
                    && request.auth.uid == request.resource.data.createdById
                    && request.auth.uid in request.resource.data.memberIds;
      
      // Only members of a group can update it.
      allow update: if isSignedIn() && request.auth.uid in resource.data.memberIds;
      
      // Only admins can delete groups directly. Archiving is handled by a server action.
      allow delete: if isAdmin();
    }

    match /expenses/{expenseId} {
      // Allow reading (get/list) expenses if the user's ID is in the document's `groupMemberIds` field.
      // This requires the client query to include `where('groupMemberIds', 'array-contains', request.auth.uid)`.
      allow read: if isGroupMember(resource.data);

      // Allow creating an expense if the user is part of the target group.
      allow create: if isGroupMember(request.resource.data);

      // Allow updating/deleting an expense if the user was a member of the group.
      allow update, delete: if isGroupMember(resource.data);
    }

    match /settlements/{settlementId} {
      allow read: if isGroupMember(resource.data);
      allow create: if isGroupMember(request.resource.data);
      allow update, delete: if isGroupMember(resource.data);
    }

    match /history/{historyId} {
      allow read: if isGroupMember(resource.data);
      
      // Creating history events should ideally be a trusted server-side action.
      // This rule allows a client to create one if they are a member.
      allow create: if isGroupMember(request.resource.data);
      
      // Only admins can modify/delete history entries.
      allow update, delete: if isAdmin();
    }
  }
}
